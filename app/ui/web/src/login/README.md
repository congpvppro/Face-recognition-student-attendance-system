
# Authentication Flow

### Core:

*   **`ky`**: A simple and powerful HTTP client we use to make requests from our SvelteKit server to our Elysia API.
*   **JWT (JSON Web Token)**: Generated by the Elysia backend to represent a logged-in user. **Crucially, the JWT is never exposed to the browser.**
*   **Cookies**: Used to store the session information securely in the user's browser. The cookie is `httpOnly`, meaning it cannot be accessed by client-side JavaScript, which prevents XSS attacks.

---

## The Authentication Flow

### 1. User Login

*   A user submits their credentials via a standard HTML `<form>` on a page like `/login`.
*   The form `POST`s the data to a SvelteKit **form action** defined in `src/routes/login/+page.server.js`.

### 2. SvelteKit Server Handles the Login

*   The SvelteKit form action receives the email and password.
*   It uses our custom `api()` function (which wraps `ky`) to send these credentials to the Elysia backend's `/api/login` endpoint.
*   The Elysia server validates the credentials. If they are correct, it generates a JWT and sends it back to our SvelteKit server.

### 3. Creating the Session Cookie

*   The SvelteKit form action receives the JWT from Elysia.
*   It **does not** send the JWT to the browser. Instead, it creates a secure, `httpOnly` cookie (e.g., named `auth`) and sets the JWT as its value.
*   SvelteKit sends this `Set-Cookie` header back to the browser. The browser automatically stores it.

### 4. Subsequent Requests & Hook

*   Whenever the user navigates to a new page (e.g., `/profile`), the browser automatically includes the `auth` cookie with the request to the SvelteKit server.
*   Our "gatekeeper" file, `src/hooks.server.js`, intercepts **every server-side request**.
*   The hook reads the `auth` cookie.
*   It then makes a request to the Elysia `/api/me` endpoint, forwarding the JWT from the cookie for validation.
*   If Elysia confirms the JWT is valid, it returns the user's data.
*   The hook stores this user data in `event.locals.user`, making it available to all subsequent server-side code for that specific request. If the token is invalid or missing, `event.locals.user` is set to `null`.

### 5. Accessing a Protected Page (like `/profile`)

*   When a user visits `/profile`, the `load` function in `src/routes/profile/+page.server.js` runs.
*   This function is extremely simple: it just checks if `locals.user` exists.
    *   If `locals.user` **exists**, it means the hook successfully authenticated the user. The `load` function returns the user data to the page component.
    *   If `locals.user` is **`null`**, it means the user is not logged in. The `load` function immediately issues a `redirect` to the `/login` page.
*   The `+page.svelte` component for the profile page receives the user data as a `data` prop and renders it.

### Simple Flow Diagram

```
                (Cookie)                      (JWT)
Browser <----------------------> SvelteKit <----------------------> Elysia API
        (Login Form, Nav)       (Hook, Load)       (API Calls via ky)
```

### Key Files to Understand

*   `src/lib/server/http.js`: Our `ky` wrapper. This is how our SvelteKit server talks to the Elysia API.
*   `src/hooks.server.js`: The central "gatekeeper". It validates the user's session on every request by checking their cookie against the API.
*   `src/routes/login/+page.server.js`: Handles the initial form submission, gets the JWT, and creates the browser cookie.
*   `src/routes/profile/+page.server.js`: An example of a protected route. It relies on the hook and redirects if the user is not authenticated.
